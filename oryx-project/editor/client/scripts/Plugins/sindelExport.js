if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Enables exporting current model in Sindel format. */ORYX.Plugins.sindelExport = ORYX.Plugins.AbstractPlugin.extend({		construct: function() {		arguments.callee.$.construct.apply(this, arguments);		this.facade.offer({			'name'				: ORYX.I18N.sindelExport.name,			'functionality'		: this.exportSindel.bind(this),			'group'				: ORYX.I18N.sindelExport.group,            'icon'				: ORYX.PATH + "images/disk.png",			'description'		: ORYX.I18N.sindelExport.desc,			'index'				: 2,			'minShape'			: 0,			'maxShape'			: 0		});			},	//main function	exportSindel: function() {		//calling the function to return de .sindel string		var sindel = this.getSerializedSindel();				name = "newEquipment";				//var json = this.facade.getSerializedJSON();		//this.openDownloadWindow(name + ".txt", teste);		//this.openDownloadWindow(name + ".json", json);		this.openDownloadWindow( name + ".sindel", sindel);			},		//this recursive function traverses the json structure and generates a new structure containing:	//		an array for classes	//		an array for relations	//		an array for all elements (classes and relations) indexed by Json resourceId	//this function receives as arguments 	//		a structure containing the arrays above	//		the actual childShape	//		a string containing the Json resourceId of the previous childShape	getAllElements: function(elements, childShapes, insideOf) {		//create the structure in the first call		if(!Array.isArray(elements)){			elements = new Array();		}		if(!Array.isArray(elements['sindelClasses'])){			elements['sindelClasses'] = new Array();		}		if(!Array.isArray(elements['sindelRelations'])){			elements['sindelRelations'] = new Array();		}		if(!Array.isArray(elements['hashElements'])){			elements['hashElements'] = new Array();		}				var sindelElementNames = new Array();		this.initSindelElementNames(sindelElementNames);				//traverses all childShapes		//primeiro coleto todos os elementos (classes e relations) e agrupo por tipo para que a declaracao seja feita em blocos		for(var i=0; i<childShapes.length; i++){			//get the stencil id (eg: Layer Network, TTF, Binds...)			var typeName = childShapes[i]['stencil']['id'];			typeName = typeName.replace(" ","_");//normalizes the name according to Sindel						if(sindelElementNames[typeName] === undefined){				alert("The stencil " + typeName + " has no equivalent mapping in Sindel.");			}else{				typeName = sindelElementNames[typeName];			}						//creates an element with the importants attributes			var element = new Object();			element['resourceId'] = childShapes[i]['resourceId'];			element['name'] = childShapes[i]['properties']['typeName'];			element['typeName'] = typeName;						//verifies if the element is a relation			if(this.isASindelRelation(typeName)){				//all relations are grouped by its types (Binds, Clients...)				//if it is the first element of a type, creates a new array for this type				if(!Array.isArray(elements['sindelRelations'][typeName])){					elements['sindelRelations'][typeName] = new Array();				}								//defines the Json resourceId target for this relation				if(childShapes[i]['outgoing'].length > 0){					element['to'] = childShapes[i]['outgoing'][0]['resourceId'];				}				 				//add this element in the array of relations				elements['sindelRelations'][typeName].push(element);							}else{				//all classes are grouped by its types (Layer Network, TTF, AF...)				//if it is the first element of a type, creates a new array for this type				if(!Array.isArray(elements['sindelClasses'][typeName])){					elements['sindelClasses'][typeName] = new Array();				}									//add this element in the array of classes				elements['sindelClasses'][typeName].push(element);								//verifies all relations that has the source in this class				for(var j=0; j < childShapes[i]['outgoing'].length; j++){					//get the Json resourceId of the relation					var outgoingResourceId = childShapes[i]['outgoing'][j]['resourceId'];										//if its necessary, create an object inside the hash array to storage the relation					if(!(outgoingResourceId in elements['hashElements'])){						elements['hashElements'][outgoingResourceId] = new Object();					}										//insert the actual class as the source class of the relation					//inside the hash array					elements['hashElements'][outgoingResourceId]['from'] = element['resourceId']; 				}								if(insideOf != ""){					if(!Array.isArray(elements['hashElements'][insideOf]['composedBy'])){						elements['hashElements'][insideOf]['composedBy'] = new Array();					}						var tam = elements['hashElements'][insideOf]['composedBy'].length;										elements['hashElements'][insideOf]['composedBy'][tam] = element['resourceId'];				}			}						//all elements are storaged in the hash array			//verifies if the element already exists before to insert			if(elements['hashElements'][element['resourceId']] === undefined){				elements['hashElements'][element['resourceId']] = element;			}else{				elements['hashElements'][element['resourceId']]['resourceId'] = element['resourceId'];				elements['hashElements'][element['resourceId']]['name'] = element['name'];				elements['hashElements'][element['resourceId']]['to'] = element['to'];							}			 			//call the function recursively to get all sub childShapes			if(childShapes[i]['childShapes'].length > 0){				this.getAllElements(elements, childShapes[i]['childShapes'], childShapes[i]['resourceId']);			}					}	},		//this function generate a string containing all sindel syntax	getSerializedSindel: function() {		//get the json structure		var canvas = this.facade.getJSON();		var sindel = "";		var elements = new Array();				//feeds elements structure with the classes and relations		this.getAllElements(elements, canvas['childShapes'], "");				//here is build the declaration of classes		for(typeName in elements['sindelClasses']){			//verify if exists typeName index in array			if(!(elements['sindelClasses'][typeName][0] === undefined)){				//start the line with the typeName				sindel += typeName + ": ";			}						//iterate for all elements of this typeName			for(var j=0; j<elements['sindelClasses'][typeName].length; j++){				//verify if exists typeName index in array				if(!(elements['sindelClasses'][typeName][j] === undefined)){					//set an id for this element, in order to generate a variable name					elements['sindelClasses'][typeName][j]['id'] = j;										//generate the variable concatenating the typename and the id					sindel += " "+typeName.toLowerCase()+j;										//if it is the last element, put a ";", else put a ","					if(j+1 < elements['sindelClasses'][typeName].length){						sindel += ",";					}else{						sindel += ";\n";					}									}			}					}				//here is build the relationships		for(typeName in elements['sindelRelations']){			//iterate for all elements of this typeName			for(var j=0; j<elements['sindelRelations'][typeName].length; j++){				//verify if exists typeName index in array				if(!(elements['sindelRelations'][typeName][j] === undefined)){					//get the resourceId of the relation					var relResourceId = elements['sindelRelations'][typeName][j]['resourceId'];										//get the resourceId of the source class					var sourceResourceId = elements['hashElements'][relResourceId]['from'];					//get the resourceId of the target class					var toResourceId = elements['hashElements'][relResourceId]['to'];										//generate the variable name of the source class					var var1 = elements['hashElements'][sourceResourceId]['typeName']+elements['hashElements'][sourceResourceId]['id'];					var1 =  var1.toLowerCase();										//generate the variable name of the target class					var var2 = elements['hashElements'][toResourceId]['typeName']+elements['hashElements'][toResourceId]['id'];					var2 =  var2.toLowerCase();										//put the relationship in the resulting sindel code					sindel += typeName + "(" + var1 + "," + var2 + ");\n";				}							}		}				for(rId in elements['hashElements']){			if(!(elements['hashElements'][rId]['composedBy'] === undefined)){				var var1 = elements['hashElements'][rId]['typeName']+elements['hashElements'][rId]['id'];				var1 =  var1.toLowerCase();				sindel += var1				sindel += "{"									for(var j=0; j<elements['hashElements'][rId]['composedBy'].length; j++){					if(!(elements['hashElements'][rId]['composedBy'] === undefined)){						partId = elements['hashElements'][rId]['composedBy'][j];												var var2 = elements['hashElements'][partId]['typeName']+elements['hashElements'][partId]['id'];						var2 =  var2.toLowerCase();												sindel += var2;												if(j+1 < elements['hashElements'][rId]['composedBy'].length){							sindel += ",";						}					}				}								sindel += "};\n"			}		}				return sindel;	},		//this function verify if the element type is a sindel relation 	isASindelRelation: function(typeName) {		switch(typeName){			case "Binds":			case "Clients":			case "Connects":			case "Transport_Entity":			case "Trail":			case "NC":			case "LC":			case "MC":			case "SNC":				return true;				break;		}		return false;	},		initSindelElementNames: function(sindelElementNames){		sindelElementNames['Termination_Function'] = 'tf';		sindelElementNames['Termination_Source'] = 'so-tf';		sindelElementNames['Termination_Sink'] = 'sk-tf';		sindelElementNames['Bidirectional_Termination'] = 'bi-tf';		sindelElementNames['Adaptation_Function'] = 'af';		sindelElementNames['Adaptation_Source'] = 'so-af';		sindelElementNames['Adaptation_Sink'] = 'sk-af';		sindelElementNames['Bidirectional_Adaptation'] = 'bi-af';		sindelElementNames['Layer_Processor_Function'] = 'lpf';		sindelElementNames['Layer_Processor_Function_Source'] = 'so-lpf';		sindelElementNames['Layer_Processor_Function_Sink'] = 'sk-lpf';		sindelElementNames['Bidirectional_Layer_Processor_Function'] = 'bi-lpf';		sindelElementNames['Matrix'] = 'matrix';		sindelElementNames['Unidirectional_Matrix'] = 'uni-matrix';		sindelElementNames['Source_Matrix'] = 'so-matrix';		sindelElementNames['Unidirectional_Sink-Source_Matrix'] = 'so-matrix';		sindelElementNames['Sink_Matrix'] = 'sk-matrix';		sindelElementNames['Unidirectional_Sink-Source_Matrix'] = 'sk-matrix';		sindelElementNames['Bidirectional_Matrix'] = 'bi-matrix';		sindelElementNames['Subnetwork'] = 'sn';		sindelElementNames['Physical_Media'] = 'pm';		sindelElementNames['Input'] = 'input';		sindelElementNames['Output'] = 'output';		sindelElementNames['Reference_Point'] = 'rp';		sindelElementNames['Forwarding_End_Point'] = 'fep';		sindelElementNames['Access_Point'] = 'ap';		sindelElementNames['Forwarding_Point'] = 'fp';		sindelElementNames['Transport_Entity'] = 'te';		sindelElementNames['Access_Transport_Entity'] = 'ate';		sindelElementNames['Network_Connection'] = 'nc';		sindelElementNames['Link_Connection'] = 'lc';		sindelElementNames['Matrix_Connection'] = 'mc';		sindelElementNames['Channel_Forwarding_Transport_Entity'] = 'cfte';		sindelElementNames['Layer_Network'] = 'layer';		sindelElementNames['Equipment'] = 'equip';		sindelElementNames['Input_Interface'] = 'in_int';		sindelElementNames['Output_Interface'] = 'out_int';		sindelElementNames['Site'] = 'site';	}	});