if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Enables exporting current model in Sindel format. */ORYX.Plugins.sindelExport = ORYX.Plugins.AbstractPlugin.extend({		construct: function() {		arguments.callee.$.construct.apply(this, arguments);		this.facade.offer({			'name'				: ORYX.I18N.sindelExport.name,			'functionality'		: this.exportSindel.bind(this),			'group'				: ORYX.I18N.sindelExport.group,			dropDownGroupIcon	: ORYX.PATH + "images/disk.png",			'icon'				: ORYX.PATH + "images/page_white_javascript.png",			'description'		: ORYX.I18N.sindelExport.desc,			'index'				: 2,			'minShape'			: 0,			'maxShape'			: 0		});			},	//main function	exportSindel: function() {		//calling the function to return de .sindel string		var sindel = this.getSerializedSindel();				name = "newEquipment";				//var json = this.facade.getSerializedJSON();		//this.openDownloadWindow(name + ".txt", teste);		//this.openDownloadWindow(name + ".json", json);		this.openDownloadWindow( name + ".sindel", sindel);			},		//this recursive function traverses the json structure and generates a new structure containing:	//		an array for classes	//		an array for relations	//		an array for all elements (classes and relations) indexed by Json resourceId	//this function receives as arguments 	//		a structure containing the arrays above	//		the actual childShape	//		a string containing the Json resourceId of the previous childShape	getAllElements: function(elements, childShapes, insideOf) {		//create the structure in the first call		if(!Array.isArray(elements)){			elements = new Array();		}		if(!Array.isArray(elements['sindelClasses'])){			elements['sindelClasses'] = new Array();		}		if(!Array.isArray(elements['sindelRelations'])){			elements['sindelRelations'] = new Array();		}		if(!Array.isArray(elements['hashElements'])){			elements['hashElements'] = new Array();		}				var sindelElementNames = new Array();		this.initSindelElementNames(sindelElementNames);				//traverses all childShapes		//primeiro coleto todos os elementos (classes e relations) e agrupo por tipo para que a declaracao seja feita em blocos		for(var i=0; i<childShapes.length; i++){			//get the stencil id (eg: Layer Network, TTF, Binds...)			var typeName = childShapes[i]['stencil']['id'];			//typeName = typeName.replace(" ","_");//normalizes the name according to Sindel						if(sindelElementNames[typeName] === undefined){				alert("The stencil " + typeName + " has no equivalent mapping in Sindel.");			}else{				typeName = sindelElementNames[typeName];			}						//creates an element with the importants attributes			var element = new Object();			element['resourceId'] = childShapes[i]['resourceId'];			element['typeName'] = typeName;						//get the name property			if(!(childShapes[i]['properties']['typeName'] === undefined)){				element['name'] = childShapes[i]['properties']['typeName'];			}else if(!(childShapes[i]['properties']['name'] === undefined)){				element['name'] = childShapes[i]['properties']['name'];			}else{				element['name'] = "";			}											//get geo location properties			if(!(childShapes[i]['properties']['aliaslocation'] === undefined)){				element['location'] = new Object();								element['location']['latitude degree'] = childShapes[i]['properties']['latitude degree'];				element['location']['latitude minute'] = childShapes[i]['properties']['latitude minute'];				element['location']['latitude second'] = childShapes[i]['properties']['latitude second'];				element['location']['longitude degree'] = childShapes[i]['properties']['longitude degree'];				element['location']['longitude minute'] = childShapes[i]['properties']['longitude minute'];				element['location']['longitude second'] = childShapes[i]['properties']['longitude second'];				element['location']['aliaslocation'] = childShapes[i]['properties']['aliaslocation'];			}						//verifies if the element is a relation			if(this.isASindelRelation(typeName)){				//all relations are grouped by its types (Binds, Clients...)				//if it is the first element of a type, creates a new array for this type				if(!Array.isArray(elements['sindelRelations'][typeName])){					elements['sindelRelations'][typeName] = new Array();				}								//defines the Json resourceId target for this relation				if(childShapes[i]['outgoing'].length > 0){					element['to'] = childShapes[i]['outgoing'][0]['resourceId'];				}				 				//add this element in the array of relations				elements['sindelRelations'][typeName].push(element);							}else{				//all classes are grouped by its types (Layer Network, TTF, AF...)				//if it is the first element of a type, creates a new array for this type				if(!Array.isArray(elements['sindelClasses'][typeName])){					elements['sindelClasses'][typeName] = new Array();				}									//add this element in the array of classes				elements['sindelClasses'][typeName].push(element);								//verifies all relations that has the source in this class				for(var j=0; j < childShapes[i]['outgoing'].length; j++){					//get the Json resourceId of the relation					var outgoingResourceId = childShapes[i]['outgoing'][j]['resourceId'];										//if its necessary, create an object inside the hash array to storage the relation					if(!(outgoingResourceId in elements['hashElements'])){						elements['hashElements'][outgoingResourceId] = new Object();					}										//insert the actual class as the source class of the relation					//inside the hash array					elements['hashElements'][outgoingResourceId]['from'] = element['resourceId']; 				}								//verify if the element is composing another 				if(insideOf != ""){					if(!Array.isArray(elements['hashElements'][insideOf]['composedBy'])){						elements['hashElements'][insideOf]['composedBy'] = new Array();					}						var tam = elements['hashElements'][insideOf]['composedBy'].length;										elements['hashElements'][insideOf]['composedBy'][tam] = element['resourceId'];				}			}						//all elements are storaged in the hash array			//verifies if the element already exists before to insert			if(elements['hashElements'][element['resourceId']] === undefined){				elements['hashElements'][element['resourceId']] = element;			}else{				elements['hashElements'][element['resourceId']]['resourceId'] = element['resourceId'];				elements['hashElements'][element['resourceId']]['name'] = element['name'];				elements['hashElements'][element['resourceId']]['to'] = element['to'];							}			 			//call the function recursively to get all sub childShapes			if(childShapes[i]['childShapes'].length > 0){				this.getAllElements(elements, childShapes[i]['childShapes'], childShapes[i]['resourceId']);			}					}	},		//this function generate a string containing all sindel syntax	getSerializedSindel: function() {		//get the json structure		var canvas = this.facade.getJSON();		var sindel = "";		var elements = new Array();				//feeds elements structure with the classes and relations		this.getAllElements(elements, canvas['childShapes'], "");				//here is build the declaration of classes		for(typeName in elements['sindelClasses']){			//verify if exists typeName index in array			if(!(elements['sindelClasses'][typeName][0] === undefined)){				//start the line with the typeName				sindel += typeName + ": ";			}						//iterate for all elements of this typeName			for(var j=0; j<elements['sindelClasses'][typeName].length; j++){				//verify if exists typeName index in array				if(!(elements['sindelClasses'][typeName][j] === undefined)){					//set an id for this element, in order to generate a variable name					elements['sindelClasses'][typeName][j]['id'] = j+1;										//generate the variable concatenating the typename and the id					var varName = typeName.toLowerCase()+(j+1);					varName = varName.replace("-","_");					sindel += " "+varName;										//if it is the last element, put a ";", else put a ","					if(j+1 < elements['sindelClasses'][typeName].length){						sindel += ",";					}else{						sindel += ";\n";					}									}			}					}				//here is build the declaration of classes		for(typeName in elements['sindelClasses']){			//iterate for all elements of this typeName			for(var j=0; j<elements['sindelClasses'][typeName].length; j++){				//verify if exists typeName index in array				if(!(elements['sindelClasses'][typeName][j] === undefined)){					if(!(elements['sindelClasses'][typeName][j]['location'] === undefined)){						var latDeg = elements['sindelClasses'][typeName][j]['location']['latitude degree'];						var latMin = elements['sindelClasses'][typeName][j]['location']['latitude minute'];						var latSec = elements['sindelClasses'][typeName][j]['location']['latitude second'];						var lonDeg = elements['sindelClasses'][typeName][j]['location']['longitude degree'];						var lonMin = elements['sindelClasses'][typeName][j]['location']['longitude minute'];						var lonSec = elements['sindelClasses'][typeName][j]['location']['longitude second'];						var alias = elements['sindelClasses'][typeName][j]['location']['aliaslocation'];												var var1 = elements['sindelClasses'][typeName][j]['typeName']+elements['sindelClasses'][typeName][j]['id'];						var1 =  var1.toLowerCase();						var1 = var1.replace("-","_");												if(latDeg !== undefined && latMin !== undefined && latSec !== undefined && lonDeg !== undefined && lonMin !== undefined && lonSec !== undefined && latDeg != "" && latMin != "" && latSec != "" && lonDeg != "" && lonMin != "" && lonSec != ""){							sindel += var1 + ".location:(";							sindel += latDeg + ":" + latMin + ":" + latSec;							sindel += ",";							sindel += lonDeg + ":" + lonMin + ":" + lonSec;							sindel += ");\n";						}												if(alias != "" && alias !== undefined ){							sindel += var1 + ".location:";							sindel += alias + ";";													}					}				}			}					}				//here is build the relationships		for(typeName in elements['sindelRelations']){			//iterate for all elements of this typeName			for(var j=0; j<elements['sindelRelations'][typeName].length; j++){				//verify if exists typeName index in array				if(!(elements['sindelRelations'][typeName][j] === undefined)){					//get the resourceId of the relation					var relResourceId = elements['sindelRelations'][typeName][j]['resourceId'];										//get the resourceId of the source class					var sourceResourceId = elements['hashElements'][relResourceId]['from'];					//get the resourceId of the target class					var toResourceId = elements['hashElements'][relResourceId]['to'];										//generate the variable name of the source class					var var1 = elements['hashElements'][sourceResourceId]['typeName']+elements['hashElements'][sourceResourceId]['id'];					var1 = var1.toLowerCase();					var1 = var1.replace("-","_");										//generate the variable name of the target class					var var2 = elements['hashElements'][toResourceId]['typeName']+elements['hashElements'][toResourceId]['id'];					var2 = var2.toLowerCase();					var2 = var2.replace("-","_");										if(typeName == "PartOf"){						sindel += var2 + "{" + var1 + "};\n";					}else{						//put the relationship in the resulting sindel code						sindel += typeName + "(" + var1 + "," + var2 + ");\n";					}									}			}		}				//here is built the element composition		for(rId in elements['hashElements']){			//verify if the element is composed			if(!(elements['hashElements'][rId]['composedBy'] === undefined)){				//build the variable name of the composed element 				var var1 = elements['hashElements'][rId]['typeName']+elements['hashElements'][rId]['id'];				var1 =  var1.toLowerCase();				var1 = var1.replace("-","_");				sindel += var1				sindel += "{"									//get all composing elements				for(var j=0; j<elements['hashElements'][rId]['composedBy'].length; j++){					if(!(elements['hashElements'][rId]['composedBy'] === undefined)){						partId = elements['hashElements'][rId]['composedBy'][j];												//build the variable name of the composing elements						var var2 = elements['hashElements'][partId]['typeName']+elements['hashElements'][partId]['id'];						var2 = var2.toLowerCase();						var2 = var2.replace("-","_");												sindel += var2;												if(j+1 < elements['hashElements'][rId]['composedBy'].length){							sindel += ",";						}					}				}								sindel += "};\n"			}		}				return sindel;	},		//this function verify if the element type is a sindel relation 	isASindelRelation: function(typeName) {		switch(typeName){			case "binds":			case "clients":			case "connects":			case "maps":			case "te":			case "ate":			case "nc":			case "lc":			case "mc":			case "cfte":			case "PartOf":				return true;				break;		}		return false;	},		initSindelElementNames: function(sindelElementNames){		//Termination Functions		sindelElementNames['TF'] = 'tf';//		sindelElementNames['Source TF'] = 'so-tf';//		sindelElementNames['Sink TF'] = 'sk-tf';//		sindelElementNames['Bidirectional TF'] = 'bi-tf';//				//Adaptation Functions		sindelElementNames['AF'] = 'af';//		sindelElementNames['Source AF'] = 'so-af';//		sindelElementNames['Sink AF'] = 'sk-af';//		sindelElementNames['Bidirectional AF'] = 'bi-af';//				//Layer Processor Functions		sindelElementNames['LPF'] = 'lpf';//		sindelElementNames['Source LPF'] = 'so-lpf';//		sindelElementNames['Sink LPF'] = 'sk-lpf';//		sindelElementNames['Bidirectional LPF'] = 'bi-lpf';//				//Matrices		sindelElementNames['Matrix'] = 'matrix';		sindelElementNames['Unidirectional Matrix'] = 'uni-matrix';//		sindelElementNames['Source Matrix'] = 'so-matrix';//		sindelElementNames['Sink Matrix'] = 'sk-matrix';//		sindelElementNames['Bidirectional Matrix'] = 'bi-matrix';//				//Subnetwork		sindelElementNames['Subnetwork'] = 'sn';//				//Physical Media		sindelElementNames['Physical Media'] = 'pm';//				//Ports		sindelElementNames['Input'] = 'input';//		sindelElementNames['Output'] = 'output';//				//Reference Points		sindelElementNames['Reference_Point'] = 'rp';		sindelElementNames['FEP'] = 'fep';//		sindelElementNames['AP'] = 'ap';//		sindelElementNames['FP'] = 'fp';//				//Transport Entities		sindelElementNames['Transport Entity'] = 'te';//		sindelElementNames['ATE'] = 'ate';//		sindelElementNames['NC'] = 'nc';//		sindelElementNames['LC'] = 'lc';//		sindelElementNames['MC'] = 'mc';		sindelElementNames['CFTE'] = 'cfte';//				//Layer Network		sindelElementNames['Layer Network'] = 'layer';//				//Equipment		sindelElementNames['Equipament'] = 'equip';//				//Interfaces		sindelElementNames['Input Interface'] = 'in-int';//		sindelElementNames['Output Interface'] = 'out-int';//				//Site		sindelElementNames['Site'] = 'site';//				//Simple Relation		sindelElementNames['Binds'] = 'binds';//		sindelElementNames['Clients'] = 'clients';//		sindelElementNames['Maps'] = 'maps';//		sindelElementNames['Connects'] = 'connects';//				sindelElementNames['PartOf'] = 'PartOf';//	}	});